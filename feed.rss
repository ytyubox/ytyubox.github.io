<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content"><channel><title>游諭 Swift Dev 🦄</title><description>iOS 開發者, 喜歡研究新事物, 生酮食用者</description><link>https://ytyubox.github.io/</link><language>zh</language><lastBuildDate>Sat, 21 Mar 2020 23:04:58 +0000</lastBuildDate><pubDate>Sat, 21 Mar 2020 23:04:58 +0000</pubDate><ttl>250</ttl><atom:link href="https://ytyubox.github.io/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">https://ytyubox.github.io/posts/2020/Swift-oop-type-casting</guid><title>Swift 物件導向的型別解讀</title><description>解釋 Swift 型別是什麼，含轉型、型別抹除、還有Swift 5.1 的 some</description><link>https://ytyubox.github.io/posts/2020/Swift-oop-type-casting</link><pubDate>Sun, 22 Mar 2020 00:00:00 +0000</pubDate><content:encoded><![CDATA[<h1>Swift 物件導向的型別解讀</h1><p>在 Swift 中，原生型別有 Int、Double、String 等等，有時候我們會看到 <code>Int("1")</code>，有時候卻看到 <code>cell as! MyCell</code>，到底這哪裡不一樣，<code>as</code>, <code>as?/as!</code> 的差別在哪，這篇文章我將用我的解讀來說明一次。 &gt; 強調： 這篇不會提到 <code>Any</code>、<code>AnyObject</code>，但請記得這兩個是 Swift 的上帝型別。</p><h2>先備知識</h2><p>由於這是一個稍微進階的主題，你應該要先可以回答下面的問題，如果你對於問題不是很理解，或是想對對看答案，歡迎留言： 1. <code>init</code> 是一個 object function 還是 classstatic function? 2. 說明 <code>Int("5")</code> 是什麼意思 3. class A 與 class B 同時繼承於 class C，A 有的 function ，B 一定會有嗎？ C 有的 function， B 一定會有嗎？</p><h2>Swift 型別</h2><p>在 Swift 中，型別一直是一個很麻煩的事情，例如以下的Value type (V)：</p><pre><code><span class="keyword">let</span> float: <span class="type">Float</span> = <span class="number">1.0</span>
<span class="keyword">let</span> cgFloat:<span class="type">CGFloat</span> = <span class="type">CGFloat</span>(float)
</code></pre><p>或是 class 的 Referance type (R)：</p><pre><code><span class="keyword">extension</span> <span class="type">ViewController</span>: <span class="type">UIScrollViewDelegate</span> {
	<span class="keyword">func</span> scrollViewDidScroll(<span class="keyword">_</span> scrollView: <span class="type">UIScrollView</span>) {
		<span class="keyword">let</span> tableView = scrollView <span class="keyword">as</span>! <span class="type">UITableView</span> <span class="comment">//</span> 
	}
}
</code></pre><p>在這裡我認為這兩個例子要不同解釋： 1. 不論是R/V type，任何透過 <code>init</code> 的行為稱為 “用其他物件產生一個指定物件” 2. <code>as</code> 稱為轉型，<code>繼承型別 as Super型別</code> 我稱呼為上轉型、<code>Super型別 as!/as? 繼承型別</code> 則為嘗試轉型！</p><h2>物件導向的繼承</h2><p>在 Swift 的物件導向中，我們可以發現 UIKit 中有許多 class 是繼承自同一個基礎類別，像是 UIButton、UITableView 都是繼承於 UIView，這裏為了讓不熟悉 UIKit 的朋友可以跟上，我們簡單回顧一下物件導向的繼承，如果你已經理解繼承的可以跳過。</p><p>請參考以下 UML 圖形，這是參考<a href="https://zh.wikipedia.org/wiki/%E7%94%9F%E7%89%A9%E5%88%86%E9%A1%9E%E6%B3%95">生物分類法</a>所生成的圖像，生物是最高等級的分類，旗下有兩個分支，分別代表植物界、動物界。</p><pre><code>       +---------+
    <span class="keyword">class</span> 生物(真核域)
      +---------+
           ▲
     +-----+-----+
     |           |
+--------+  +--------+
<span class="keyword">class</span> 植物   <span class="keyword">class</span> 動物
+--------+  +--------+
</code></pre><p>而做為一位人類，我們與貓狗的距離是這樣的：</p><pre><code>                  +---------+
                 <span class="keyword">class</span> 哺乳類
                 +---------+
                      ▲
             +--------+----------+
             |                   |
        +--------+          +--------+
        <span class="keyword">class</span> 食肉目         <span class="keyword">class</span> 靈長目  
        +--------+          +--------+
            ▲                  |
   +--------+--------+         |
   |                 |         |
+---------+  +---------+    +---------+
 <span class="keyword">class</span> 貓科    <span class="keyword">class</span> 犬科     <span class="keyword">class</span> 人科 
+---------+  +---------+    +---------+
</code></pre><p>因此我們可以寫出這個分類的 Swift code：</p><pre><code><span class="keyword">class</span> 生物 {}
<span class="keyword">class</span> 植物: <span class="call">生物</span> {}
<span class="keyword">class</span> 動物: <span class="call">生物</span> {}
<span class="keyword">class</span> 哺乳類: <span class="call">動物</span> {}
<span class="keyword">class</span> 食肉目: <span class="call">哺乳類</span> {}
<span class="keyword">class</span> 靈長目: <span class="call">哺乳類</span> {}
<span class="keyword">class</span> 貓科: <span class="call">食肉目</span> {}
<span class="keyword">class</span> 犬科: <span class="call">食肉目</span> {}
<span class="keyword">class</span> 人科: <span class="call">靈長目</span> {}
</code></pre><p>如此一般，只要是動物一下的，不論是貓、狗、人，都是哺乳類，同時都具有動物該有的特性，因此我們可以說，動物是哺乳類的 <code>super</code>，貓、狗、人都是繼承於哺乳類。</p><h2>來說說 as 與 as!/as?</h2><p>在 Swift 用到 as 有兩種機會：繼承與別名(typealias)，為了不混淆視聽，typealias 的部分不會在這篇文章解釋。 在上面我們實作了一個繼承關係樹，我們現在要開始使用這個關係了。假如今天發現的一個 Z 病毒，他的作用範圍是人類，可以用以下的方式實作：</p><pre><code><span class="keyword">extension</span> 人科 {
  <span class="keyword">func</span> 生病() { }
}

<span class="keyword">class</span> Z病毒 {
  <span class="keyword">func</span> 把它弄生病(誰 那個人: 人科) {
    那個人.<span class="call">生病</span>()
  }
}

<span class="keyword">let</span> 游諭 = <span class="call">人科</span>()
<span class="keyword">let</span> 我家養的貓 = <span class="call">貓科</span>()
<span class="keyword">let</span> 很恐怖的Z病毒 = <span class="type">Z病毒</span>()
很恐怖的Z病毒.<span class="call">把它弄生病</span>(誰: 游諭)
很恐怖的Z病毒.<span class="call">把它弄生病</span>(誰: 我家養的貓) <span class="comment">// compile error</span>
</code></pre><p>可以看到我們的 <code>Z 病毒</code> 可以感染 <code>人</code> 但不能感染 <code>貓</code>，原因是 <code>Z 病毒</code> 無法將不是人科的 Objcet 作為參考。 但是有一天，Z 病毒進化成可以感染貓科動物，或許你想到我們可以用 <code>as！</code> 的方式來處理：</p><pre><code><span class="keyword">let</span> 我家養的貓人 = 我家養的貓 <span class="keyword">as</span>! 人科 <span class="comment">// run-time error</span>
virusZ.<span class="call">把它弄生病</span>(誰: 我家養的貓人)
</code></pre><p>仔細想想，kitty 有可能是人嗎？ 很可惜並不會☹️。因此我們可以為 Z 病毒新增一個感染貓的 function：</p><pre><code><span class="keyword">extension</span> <span class="type">Z病毒</span> {
  <span class="keyword">func</span> 把它弄生病(誰 那個貓: 貓科) {
    那個貓.<span class="call">生病</span>()
  }
}
</code></pre><p>但隨著時間演進，Z 病毒發生變化，只要是哺乳類都會感染，這要怎麼設計呢？或許你會在 Z 病毒為每一個哺乳類的繼承類別實作一個同名函式，但是有更好的方法，可以針對哺乳類實作：</p><pre><code><span class="keyword">extension</span> <span class="type">Z病毒</span> {
  <span class="keyword">func</span> 把它弄生病(誰 那個哺乳類: 哺乳類) {
    那個哺乳類.<span class="call">生病</span>()
  }
}

<span class="keyword">let</span> 隔壁養的狗 = <span class="call">犬科</span>()
<span class="keyword">let</span> 某個哺乳類: 哺乳類 = 隔壁養的狗 <span class="keyword">as</span> 哺乳類 
很恐怖的Z病毒.<span class="call">把它弄生病</span>(誰: 某個哺乳類)
</code></pre><p>Swift 作為你的好朋友，他知道犬科成為一個哺乳類是一定會成功的，所以我們可以不使用 <code>as!/as?</code> 來嘗試，而且這真的一定會成功，所以 Swift 可以直接忽略這麼一個事情！</p><pre><code>很恐怖的Z病毒.<span class="call">把它弄生病</span>(誰: 隔壁養的狗)
</code></pre><blockquote><p>在此，我習慣將這個一個把繼承物件轉型成 Super 型別的動作稱為 <code>上轉型</code>，其背後的意義是 [[型別抹除-wiki]](https://en.wikipedia.org/wiki/Type_erasure) 的一種，把衍生類型轉成基本類型隱藏起來，通過基礎類別的多型呼叫虛擬函式隱藏類的實現。</p></blockquote><p>有一天科學家發現，Z病毒不會對鴨嘴獸感染，你要如何處理這個特例而且不需要取消 <code>那個哺乳類</code>，這時候你可以用型別推斷 <code>is</code> 來進行：</p><pre><code>+<span class="keyword">class</span> 鴨嘴獸: <span class="call">哺乳類</span> {
  <span class="keyword">override func</span> 生病() {
    <span class="call">fatalError</span>(<span class="string">"鴨嘴獸不會生病"</span>)
  }
  <span class="keyword">func</span> 遇到病毒(<span class="keyword">_</span> 病毒: <span class="type">Z病毒</span>) {  }
}

<span class="comment">// 修改上面的程式碼</span>
<span class="keyword">extension</span> <span class="type">Z病毒</span> {
  <span class="keyword">func</span> 把它弄生病(誰 那個哺乳類: 哺乳類) {
    <span class="keyword">if</span> 那個哺乳類 <span class="keyword">is</span> 鴨嘴獸 {
      <span class="keyword">let</span> 那個哺乳類是鴨嘴獸 = 那個哺乳類 <span class="keyword">as</span>! 鴨嘴獸
      那個哺乳類是鴨嘴獸.<span class="call">遇到病毒</span>(<span class="keyword">self</span>)
      <span class="keyword">return</span>
    } 
    那個哺乳類.<span class="call">生病</span>()
  }
}
</code></pre><p>如此一來，我們只要對 Z 病毒的感染能力針對鴨嘴獸修改，就可以使程式運作正常。</p><blockquote><p>在此，我習慣把這種 <code>Super型別 is/as!/as? 繼承型別</code> 稱為嘗試轉型！</p></blockquote><h2>[進階] 你懂了之後，可以試試看 Swift 5.1 的 Opaque Return Types</h2><p>在講之前，你需要能回答以下的問題： 1. associatedtype 的可宣告範圍(層級)是哪裏？ 2. Any 與 AnyObject 是什麼？為什麼不能 <code>class SOME: AnyObject</code></p><p>由於 Swift 沒有抽象類別而用 protocol 來替換 interface，尤其是泛型(generic) 的 protocol，無法使用 <code>SOMEProtocol&lt;Int&gt;</code> 來寫，所以一直以來這部分有些雞肋。然而 Swift 5.1 有了 Opaque Return Types(ORT)，我們現在可以使下面的程式碼成立：</p><pre><code><span class="keyword">protocol</span> 某個有泛型的 {
   <span class="keyword">associatedtype</span> 那個泛型
}
<span class="keyword">class</span> 泛型類別&lt;是個泛型&gt;: <span class="call">某個有泛型的</span> {
  <span class="keyword">typealias</span> 那個泛型 = 是個泛型
}

<span class="keyword">func</span> 一個會回傳的函式() -&gt; <span class="keyword">some</span> 某個有泛型的 {
    <span class="keyword">return</span> 泛型類別&lt;<span class="type">Int</span>&gt;()
}

<span class="keyword">let</span> 某個有泛型: <span class="keyword">some</span> 某個有泛型的 = <span class="call">一個會回傳的函式</span>()
</code></pre><p>可以看到 ORT 可以做到將有 associatedtype 的 protocol 作為變數，但是目前有幾個地方是做不到的： 1. 將 some 變數放在集合中，如 Array 2. 可能回傳不同 Base class 的狀況</p><pre><code><span class="keyword">protocol</span> P { <span class="keyword">associatedtype</span> PP }

<span class="keyword">class</span> G&lt;T&gt;:<span class="type">P</span> { <span class="keyword">typealias</span> PP = <span class="type">T</span> }
<span class="keyword">class</span> H&lt;T&gt;:<span class="type">P</span> { <span class="keyword">typealias</span> PP = <span class="type">T</span> }

<span class="keyword">func</span> s(b:<span class="type">Bool</span>) -&gt; <span class="keyword">some</span> <span class="type">P</span> {
  b ? <span class="type">G</span>&lt;<span class="type">Int</span>&gt;() : <span class="type">H</span>&lt;<span class="type">Int</span>&gt;()  <span class="comment">// 😨 compile error，因為 G 和 H 沒有共同的 base class</span>
}


<span class="keyword">class</span> Base&lt;T&gt;:<span class="type">P</span> {<span class="keyword">typealias</span> PP = <span class="type">T</span>}
<span class="keyword">class</span> G&lt;T&gt;: <span class="type">Base</span>&lt;T&gt;{
}
<span class="keyword">class</span> H&lt;T&gt;: <span class="type">Base</span>&lt;T&gt;{
}
<span class="keyword">func</span> s(b:<span class="type">Bool</span>) -&gt; <span class="keyword">some</span> <span class="type">P</span> {
  b ? <span class="type">G</span>&lt;<span class="type">Int</span>&gt;() : <span class="type">H</span>&lt;<span class="type">Int</span>&gt;()
}
<span class="comment">// Complie 成功，因為 G 和 H 有共同的 base class，且其也是該 protocol</span>

</code></pre><p>這是我在寫 Combine 時追查文件時靈機一動，將 <code>return AnyPublisher</code> 改為 <code>return some Publisher</code> 發現的，雖然現在沒有辦法在 SwiftUI 之外順利銜接。</p><h2>結語</h2><p>型別在物件導向中，有許多有趣的特性，在強型別的程式語言尤其明顯，而 Swift 更進一步有 Protocol Oriented Programming 的發展走向，使得型別不再有以繼承關係出現，而可以更彈性的處理。</p>]]></content:encoded></item><item><guid isPermaLink="true">https://ytyubox.github.io/posts/2020/Fluent-interface-in-swift</guid><title>運用泛型實現 Fluent interface Setter</title><description>介紹 Fluent interface 及在 Swift 的實作</description><link>https://ytyubox.github.io/posts/2020/Fluent-interface-in-swift</link><pubDate>Sat, 14 Mar 2020 00:00:00 +0000</pubDate><content:encoded><![CDATA[<img src="https://i.imgur.com/YOSTX3P.png"/><h1>運用泛型實現 Fluent interface Setter</h1><p>Fluent Interface(FI)，又名流式接口，是一種在程式編寫的方式，這篇文章將描述 FI 的意義與如何在 Swift 5.1 實作。</p><h2>什麼是 Fluent interface</h2><p>流式接口可以將指令式語言轉化成宣告式語言，使簡易的邏輯判斷消失，進而加強程式碼的可讀性。在 FI 中有許多應用，我分成了 3 種類型 <code>Transformer</code>, <code>Getter</code>, <code>Setter</code>。</p><h3>Transformer</h3><p>我們在操作集合類型的時候，常常使用 filter、map、reduce，像是：</p><pre><code><span class="keyword">let</span> input = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]
<span class="keyword">let</span> output = input.<span class="call">map</span>(<span class="type">String</span>.<span class="property">init</span>)
</code></pre><p>相比沒有使用 <code>map</code> 函式，我們可以使用 for in 迴圈來處理：</p><pre><code><span class="keyword">let</span> input = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]
<span class="keyword">var</span> output = [<span class="type">String</span>]()
<span class="keyword">for</span> value <span class="keyword">in</span> input {
    output.<span class="call">append</span>(<span class="type">String</span>(value))
}
</code></pre><p>在 map 函式中，可以看到原先的 input 是一個 <code>let</code> 的變數，明顯可以看到 output 的生成不會改變來源的數值，因此他是一種 <code>Transform</code> 的功能。</p><h3>Getter</h3><p>在一些常見的程式語言中常有空的概念(Null)，尤其在 Swift 中更是個不能忽略的事情。當我們要使用一個巢狀型別如下：</p><pre><code><span class="keyword">struct</span> Person {
    <span class="keyword">var</span> name:<span class="type">String</span>
    <span class="keyword">var</span> pet:<span class="type">Pet</span>?
    <span class="keyword">struct</span> Pet {
        <span class="keyword">var</span> petName:<span class="type">String</span>
        <span class="keyword">var</span> speakSound: <span class="type">String</span>?
    }
}
</code></pre><p>我們有一個 Person 型別，這個 Person 有必須的 name 屬性，和一個非必須的 pet 屬性(Pet型別)，而這個 Pet 有必須的 petName，和一個非必須的 speakSound。假如我們需要取得所有 person 的 pet 的speakSound，為了避免空的問題，我們可以用 if else 來處理：</p><pre><code><span class="comment">// [進階]：為了避免誤解，我省略了 Implicitly Unwrapped Optional</span>

<span class="keyword">let</span> theMan = <span class="type">Person</span>(name: <span class="string">"Yu"</span>, 
                    pet: <span class="type">Pet</span>(petName: <span class="string">"dog"</span>, speakSound: <span class="string">"bark"</span>))
                    
<span class="keyword">if</span> theMan.<span class="property">pet</span> != <span class="keyword">nil</span> {
    <span class="keyword">if</span> theMan.<span class="property">pet</span>.<span class="property">speakSound</span> != {
        <span class="call">print</span>(theMan.<span class="property">pet</span>.<span class="property">speakSound</span>) <span class="comment">// bark</span>
    }
}
</code></pre><p>而在 Swift 中，我們可以使用 Optional chaining 來將這個判斷封裝起來：</p><pre><code><span class="keyword">let</span> theWoman = <span class="type">Person</span>(name: <span class="string">"Swift"</span>, 
                      pet: tir)
<span class="call">print</span>(theWoman.<span class="property">pet</span>?.<span class="property">speakSound</span> ?? <span class="string">"..."</span>) <span class="comment">// ...</span>
</code></pre><p>在這個例子，我們看到使用 Optional chaining 可以大幅簡化程式碼的複雜情況，讓取得物件 property 的程式可以不需要明顯的邏輯判斷，而是將判斷封裝至 <code>?</code> 這個運算符號。</p><h3>Setter</h3><p>在物件導向設計模式中，有一個 Builder 模式(生成器模式)，它可以將複雜對象的建造過程抽象出來（抽象類別），使這個抽象過程的不同實現方法可以構造出不同表現（屬性）的對象。 <img src="https://i.imgur.com/TvKtVxO.png"/> 圖片來自 https://en.wikipedia.org/wiki/Builder_pattern</p><p>在 Swift Foundation 中，<a href="https://developer.apple.com/documentation/foundation/datecomponents">DateComponents</a> 是一個常見的 Builder：</p><pre><code><span class="keyword">var</span> dateComponents = <span class="type">DateComponents</span>()
dateComponents.<span class="property">calendar</span> = .<span class="dotAccess">current</span>
dateComponents.<span class="property">year</span> = <span class="number">2020</span>
dateComponents.<span class="property">month</span> = <span class="number">3</span>
dateComponents.<span class="property">day</span> = <span class="number">14</span>
dateComponents.<span class="property">hour</span> = <span class="number">1</span>
dateComponents.<span class="property">minute</span> = <span class="number">20</span>
dateComponents.<span class="property">second</span> = <span class="number">59</span>
dateComponents.<span class="property">date</span> <span class="comment">// 2020-03-13 17:20:59 +0000</span>
</code></pre><p>而在我的 <a href="https://github.com/ytyubox/fluentinterface">FluentInterface</a> 這個 Swift Package 中，我們可以改變這個逐步賦值的方式：</p><pre><code><span class="keyword">let</span> dateComponents = <span class="type">DateComponents</span>()+
                      .<span class="call">calendar</span>(.<span class="dotAccess">current</span>)
                      .<span class="call">year</span>(<span class="number">2020</span>)
                      .<span class="call">month</span>(<span class="number">3</span>)
                      .<span class="call">day</span>(<span class="number">14</span>)
                      .<span class="call">hour</span>(<span class="number">1</span>)
                      .<span class="call">minute</span>(<span class="number">20</span>)
                      .<span class="call">second</span>(<span class="number">59</span>)
                      .<span class="call">unwrappingSubject</span>()
                      .<span class="dotAccess">date</span>
dateComponents.<span class="property">date</span> <span class="comment">// 2020-03-13 17:20:59 +0000</span>
</code></pre><p>是不是相對的更直覺一些呢！</p><h2>FluentInterface 的不好地方</h2><img src="https://i.imgur.com/vEGbZlJ.png"/><p>在 2019 年 appcode.com.tw 的 https://www.appcoda.com.tw/fluent-interface/ 文章中，我受到不少啟發，特別分享這篇好文章。 2020 年 3 月時我在 CocoaHeads Taipei 分享了這個 repo，感謝其他與會的開發者提問有關於效能的問題，是的 FI 效率很不好，在連續 1<em>000</em>000 的 Object 生成並 賦予 60 個不同 property 相同數值時，若使用匿名函式(Anonymous Function)，單元測試顯示 10 次執行平均時間約為 <code>0.810 秒</code>； 而 FluentInterface 實測同樣條件需要 <code>15.796</code> 秒。因此在使用 FI 的時候，考慮效能在大數量的狀況是必須注意的。</p><img src="https://i.imgur.com/wbio12T.jpg"/><p>線上的 CocoaHeads Taipei 聚會</p><p>文末特別感謝許立恆、陳涵宇等等開發者。</p>]]></content:encoded></item><item><guid isPermaLink="true">https://ytyubox.github.io/posts/2020/learn-swift-without-xcode</guid><title>如何不使用 XCode 學習 Swift</title><description>介紹 swiftc 編譯器，達成使用記事本寫 code</description><link>https://ytyubox.github.io/posts/2020/learn-swift-without-xcode</link><pubDate>Sun, 8 Mar 2020 00:00:00 +0000</pubDate><content:encoded><![CDATA[<h1>如何不使用 Xcode 學習 Swift</h1><img src="https://i.imgur.com/HF8jiiX.jpg"/><p>Swift 自從於 2015 年底自 Apple inc 開源之後，有許多人想學習卻因為無法找到 Xcode 之外的開發環境，而有不少的挫責，最近因為 Swift for tensorflow 的發展，有不少人想知道 Swift 究竟有何魔力，今天介紹如何在不用 Xcode (甚至不在macOS環境) 下，編譯並學習 Swift 的語言特性！</p><h2>確認 Swift Compiler</h2><p>在開始之前，你必須自己研究出如何在自己的編譯系統安裝 Swift，我建議你學習最新版本的 Swift，就如同上面解釋的，Swift 是個開源的語言，有許多更新是集成廣大開發者的智慧，像是 2019 年 Swift 5.1 的 Property Wrapper，就改變了許多程式設計的面向。若是想要確認自己的 Swift 版本，可以使用一下指令：</p><pre><code>$ swift --version
<span class="type">Apple Swift</span> version <span class="number">5.1.3</span> (swiftlang-<span class="number">1100.0.282.1</span> clang-<span class="number">1100.0.33.15</span>)
<span class="type">Target</span>: x86_64-apple-darwin19.<span class="number">3.0</span>
</code></pre><h2>編譯 .swift 程式檔就像 clang (gcc) 一樣簡單</h2><p>在 C 語言中，我們可以使用 gcc 來編譯 <code>.c</code> 的檔案，如果今天只有一個檔案，我們仍需要 <code>int main ()</code> 的函式來充當程式的進入點(與 Python 同理)，而在 <code>swiftc</code> 這個 Swift compiler 中，若是以畫單一檔案的方式的話，並不需要 main function， 因此我們可以使用下面的方式：</p><pre><code>$ swiftc <span class="type">AnyFileName</span>.<span class="property">swift</span> -o <span class="type">SingleFile</span>.<span class="property">app</span>
$ ./<span class="type">SingleFile</span>.<span class="property">app</span>

swiftc a single file just like <span class="type">Xcode</span> playground
</code></pre><p>然而大部分時間我們並不會把所有的程式碼寫於同一個檔案，因此需要 <code>main.swift</code> 來告訴 compiler 程式的進入點在何處。</p><pre><code>$ swiftc main.<span class="property">swift</span> <span class="type">Calculator</span>.<span class="property">swift</span> hello.<span class="property">swift</span> -o <span class="type">MultipleFile</span>.<span class="property">app</span>
$ ./<span class="type">MultipleFile</span>.<span class="property">app</span>

<span class="number">1</span> + <span class="number">1</span> = <span class="number">2</span>
hello, again
</code></pre><p>以上，你就可以透過 docs.Swift.org 上的教學，不用任何 Xcode 來認識 Swift。 demo on GitHub: https://github.com/ytyubox/SwiftWithoutXcode</p><h2>[進階] 透過 Swift Package 來使用 Open-Source Library</h2><p>在學習完語法之後，我們會想開始建立自己的程式，但是不同於 C，Swift 有自主的套件管理方案，Swift Package Maneger(SPM)，當使用 Swift Package 之後，Swift 將 swiftc 的指令做了大幅度封裝。在介紹之前，如果你還不會 Swift 語法，我建議你將這個段落保留起來；如果你沒使用過 Swift Package， 可以參考我的另一篇文章： <a href="https://ytyubox.github.io/posts/SwiftCLI-helloworld/">使用 Swift Package Manager 建立 Command line tool</a></p><h2>接下來要做什麼？</h2><p>如果你在學習完 Swift 的語言之後，想試著製作一個應用程式，我建議你可以考慮一下幾個方面：</p><ol><li>使用 SPM 建立 Command line tool，簡化 Linux/Unix 流程 我有使用 SPM 建立一個 Git 的 Pre-Commit 流程，主要功能是檢查 GitSubmodule 的自動化工具，請參考 <a href="github.com/ytyubox/check-submodule-all-commit">ytyubox/check-submodule-all-commit</a></li><li>使用 <a href="https://www.tensorflow.org/swift">Swift for Tensorflow</a> 處理機器學習</li><li>製作一個 Apple OS 的 APP (iOS、macOS)</li><li>利用 Server Side Swift 建立網頁或是 API，如 <a href="https://vapor.codes/">Vapor</a></li></ol><p>如果你有製作任何讓你得到成就感的程式，歡迎你留言分享！</p>]]></content:encoded></item><item><guid isPermaLink="true">https://ytyubox.github.io/posts/2020/02/29/oop-discussion</guid><title>有物件導向的世界與沒有物件導向的世界</title><description>介紹物件導向在我的理解。</description><link>https://ytyubox.github.io/posts/2020/02/29/oop-discussion</link><pubDate>Sat, 29 Feb 2020 00:00:00 +0000</pubDate><content:encoded><![CDATA[<p>物件導向程式設計對於新手是非常困難的事情，今天我們有許多程式語言是以物件導向來運作的，像是 C++, Objective-C, Python, Swift，作為 iOS 開發者，很少看到以 Swift 為語言的物件導向教學，今天我將以 <a href="https://youtu.be/-DP1i2ZU9gk">Mit 6001 第 8 集: Object Oriented Progamming</a> 作為基礎，以 Swift 的方式分享物件導向。</p><h2>什麼是 Objects？</h2><p>Object 是一種資料的抽象，這種抽象是包含了兩個事情：它的內部零件和它的運作指令。車子是一個 Object，這個 Object 內有許多零件，像是輪胎、座椅、動力系統。每個零件都可以再視為另一個 Object，像是輪胎可以是橡皮部分、輪圈、輪圈上的螺絲釘。而車子的運作指令就是轉動方向盤、油門剎車。我們可以說，零件是物件的 property，指令是物件的 interface。 <img src="https://i.imgur.com/DU9wsuG.png"/></p><p>所以我們可以用 Swift 的 class 來說明汽車這個 Object：</p><pre><code><span class="keyword">class</span> 車子 {
    <span class="keyword">var</span> 動力系統： 動力系統種類
    
    <span class="keyword">func</span> 前進() {...}
    <span class="keyword">func</span> 後退() {...}
    <span class="keyword">func</span> 左轉() {...}
    <span class="keyword">func</span> 右轉() {...}
}

<span class="keyword">let</span> miniCooper = <span class="call">車子</span>(動力系統: .<span class="dotAccess">渦輪增壓直列4缸</span>)
<span class="keyword">let</span> 動物園馬車 = <span class="call">車子</span>(動力系統: .<span class="call">成年馬</span>(<span class="number">2</span>))
</code></pre><p>這時候我們有了 2 個型別為車子的 Object，分別是 miniCooper 和 動物園馬車。</p><h2>OBJECT ORIENTED PROGRAMMING (OOP) 的特性</h2><p>OOP 可以將一連串的資訊與 function 約束在一起，就像是商店裡的大包裝一樣沒有辦法分別購買裡面的資訊。如果沒有這個功能，我們可能會這樣寫：</p><pre><code><span class="keyword">let</span> miniCooper = <span class="call">車子</span>()
<span class="keyword">let</span> miniCooper動力系統 = 渦輪增壓直列4缸
<span class="keyword">let</span> 馬車 = <span class="call">車子</span>()
<span class="keyword">let</span> 馬車動力系統 = 成年馬2匹

<span class="keyword">func</span> miniCooper前進() {...}
<span class="keyword">func</span> 馬車前進() {...}
<span class="keyword">func</span> miniCooper後退() {...}
<span class="keyword">func</span> 馬車後退() {...}
<span class="keyword">func</span> miniCooper左轉() {...}
<span class="keyword">func</span> 馬車左轉() {...}
<span class="keyword">func</span> miniCooper右轉() {...}
<span class="keyword">func</span> 馬車右轉() {...}
</code></pre><p>相較於 OOP 的寫法，是不是多出了許多呢！為什麼會有這麼大的差異，最明顯的就是 OOP 可以使程式碼有很大程度的重複使用。當我想到重複使用，我想到環保餐具，我們使用免洗筷雖然可以有一時的方便，但是隨著用的次數變多，我們漸漸受到濫用的懲罰；程式碼也是一樣的道理，一旦我們濫用了複製貼上，隨著程式碼的複雜會逐漸出現可大可小的懲罰。</p><h2>學好 OOP 的重要心法：抽象</h2><p>設計 OOP 是一門藝術，就像是寫劇本一樣，你會知道在劇情發展下什麼是重要的，什麼是不重要的；而在物件導向裡面，可以用一些台詞來解釋物件之間的複雜關係。例如： 1. 人物設定：主角 Yu 有一把寶劍，大魔王 Swift 有一支斧頭</p><pre><code><span class="keyword">class</span> 角色 {
    <span class="keyword">let</span> name: <span class="type">String</span>
    <span class="keyword">let</span>  weapon: <span class="type">Weapon</span>
    <span class="keyword">enum</span> Weapon {
        <span class="keyword">case</span> 寶劍
        <span class="keyword">case</span> 斧頭
    }
}

<span class="keyword">let</span> <span class="type">YuTheHero</span> = <span class="call">角色</span>(name: <span class="string">"Yu"</span>,  weapon: .<span class="dotAccess">寶劍</span>)
<span class="keyword">let</span> <span class="type">SwiftTheBoss</span> = <span class="call">角色</span>(name: <span class="string">"Swift"</span>,  weapon: .<span class="dotAccess">斧頭</span>)
</code></pre><ol start="2"><li>場景設定： 一個農場、一棟城堡、一片平原</li></ol><pre><code><span class="keyword">class</span> 場景 {
    <span class="keyword">let</span> name:<span class="type">String</span>
    <span class="keyword">var</span> characterAtHere:[角色] = []
    <span class="keyword">func</span> peopleComing(<span class="keyword">_</span> people:角色) {
    ...
    }
    <span class="keyword">func</span> peopleLeaving(<span class="keyword">_</span> people:角色) {
    ...
    }
}

<span class="keyword">let</span> 農場 = <span class="call">場景</span>(name: <span class="string">"快樂農場"</span>)
<span class="keyword">let</span> 城堡 = <span class="call">場景</span>(name: <span class="string">"魔王城堡"</span>)
<span class="keyword">let</span> 平原 = <span class="call">場景</span>(name: <span class="string">"普通平原"</span>)
</code></pre><ol start="3"><li>故事： 農場裡的 Yu 離開農場，經過平原到了城堡，將魔王趕出城堡。</li></ol><pre><code><span class="comment">/* 背景設定 */</span>
農場.<span class="call">peopleComing</span>(<span class="type">YuTheHero</span>)
城堡.<span class="call">peopleComing</span>(<span class="type">SwiftTheBoss</span>)
<span class="comment">/* 劇情發展 */</span>

農場.<span class="call">peopleLeaving</span>(<span class="type">YuTheHero</span>)
平原.<span class="call">peopleComing</span>(<span class="type">YuTheHero</span>)
平原.<span class="call">peopleLeaving</span>(<span class="type">YuTheHero</span>)
城堡.<span class="call">peopleComing</span>(<span class="type">YuTheHero</span>)
城堡.<span class="call">peopleLeaving</span>(<span class="type">SwiftTheBoss</span>)
</code></pre><p>在這個例子中，我們將角色與場景抽象成為 Type，建立了 角色要有 name、weapon，場景要有 name 與 characterAtHere，這樣的設計讓我們可以產生 Yu 與 Swift 這兩個不同的角色，這些角色可以存在於不同的場景。你可能會覺得可以有不同的抽象方式，像是人物可以有Enter, leave 的 function，而不是場景；對於這個設計疑問是一件難以說明的事情，因為隨著需求(劇情)的演進，常常會有設計不適用的情形發生，所以在設計物件導向的時候需要經過仔細的思考與規劃。</p><h2>開放部分與不開放部分 (Public/Private)</h2><p>OOP 中有所謂的可視區分，我稱之 “開放部分與不開放部分”。開放(Public) 就是 Interface，不開放(Public)就是 SOP，最為有效的比喻就是機關的櫃檯： 在咖啡店的例子中，我們向咖啡店買一杯咖啡，咖啡店經過內部的一些標準製作流程，其中包含磨咖啡豆、煮水、泡咖啡、包裝咖啡，最後咖啡店將咖啡交給我們。在客人眼中，客人面對的是一間咖啡店，咖啡店接受的指令只有買咖啡。而在咖啡店內部的視角，咖啡店有咖啡原料、機器等 property，有一些指令像是磨咖啡豆、煮水、泡咖啡、包裝咖啡等等獨立的指令，這些指令不會讓客人逐一呼叫，咖啡店將這些指令設為 <code>private</code>，相對的透過 <code>public</code> 提供一個 “買咖啡” 的使得客人可以取得一份咖啡。</p><pre><code><span class="keyword">class</span> 咖啡店 {
    <span class="comment">// MARK: - Private scope</span>
    <span class="keyword">private func</span> 磨咖啡豆() -&gt; 咖啡粉 {...}
    <span class="keyword">private func</span> 煮水() -&gt; 水 {...}
    <span class="keyword">private func</span> 泡咖啡(咖啡粉,水) {...}
    <span class="keyword">private func</span> 包裝咖啡(咖啡) {...}
}
<span class="comment">// MARK: - Public scope</span>
<span class="keyword">extension</span> 咖啡店 {
  <span class="keyword">public func</span> 買咖啡() -&gt; <span class="call">咖啡產品</span> {
      <span class="keyword">let</span> 咖啡粉 = <span class="call">磨咖啡豆</span>()
      <span class="keyword">let</span> 水 = <span class="call">煮水</span>() 
      <span class="keyword">let</span> 泡好的咖啡 = <span class="call">泡咖啡</span>(咖啡粉,水)
      <span class="keyword">let</span> 包裝好的咖啡 = <span class="call">包裝咖啡</span>(泡好的咖啡)
      <span class="keyword">return</span> 包裝好的咖啡
  }
}
</code></pre><p>在這裡，我們可以說： 咖啡店將做一份咖啡這個商業機密<strong>封裝</strong>起來。</p><h2>結論： 學會了抽象與封裝之後</h2><p>OOP 有 4 大特性： 抽象、封裝、繼承、多型，我們學會了如何提取重複的抽象特性，學會了如何將步驟保護起來的封裝特性，接下來，你可以繼續學習 DRY 的技巧，繼承與多型。DRY 是 Don't Repeat Youself 的縮寫，我們已經知道可以用迴圈來做到重複的程式碼消除。</p><pre><code><span class="keyword">func</span> 罰寫7次() {
  <span class="call">print</span>(<span class="string">"我不應該重複我的程式碼"</span>)
  <span class="call">print</span>(<span class="string">"我不應該重複我的程式碼"</span>)
  <span class="call">print</span>(<span class="string">"我不應該重複我的程式碼"</span>)
  <span class="call">print</span>(<span class="string">"我不應該重複我的程式碼"</span>)
  <span class="call">print</span>(<span class="string">"我不應該重複我的程式碼"</span>)
  <span class="call">print</span>(<span class="string">"我不應該重複我的程式碼"</span>)
  <span class="call">print</span>(<span class="string">"我不應該重複我的程式碼"</span>)
}
</code></pre><p>如今，你學會了物件導向，你也不應該做這樣的事情：</p><pre><code><span class="keyword">class</span> 小學生 {
    <span class="keyword">func</span> 罰寫n次(n: <span class="type">Int</span>) {
        <span class="keyword">for _ in</span> <span class="number">0</span>..&lt;n {
          <span class="call">print</span>(<span class="string">"我不應該重複我的程式碼"</span>)
        }
    }
}
<span class="keyword">class</span> 大學生 {
    <span class="keyword">func</span> 罰寫n次(n: <span class="type">Int</span>) {
        <span class="keyword">for _ in</span> <span class="number">0</span>..&lt;n {
          <span class="call">print</span>(<span class="string">"我不應該重複我的程式碼"</span>)
        }
    }
}
</code></pre><p>而繼承與多型可以有效的處理這個 DRY 的問題！</p>]]></content:encoded></item><item><guid isPermaLink="true">https://ytyubox.github.io/posts/SwiftCLI-helloworld</guid><title>使用 Swift Package Manager 建立 Command line tool</title><description>如何使用 Swift Package Manager(SPM) 與 Linux/Unix 互動</description><link>https://ytyubox.github.io/posts/SwiftCLI-helloworld</link><pubDate>Sat, 22 Feb 2020 00:00:00 +0000</pubDate><content:encoded><![CDATA[<h1>使用 Swift Package Manager 建立 Command line tool</h1><p>Command line tool 有時候可以方便的處理一些常見的任務，有時候可以將開放中遇到的瑣碎事情自動化處理，例如 <a href="https://github.com/yonaskolb/XcodeGen">XcodeGen</a>就是一個有趣的應用。這篇文章將教你如何使用 Swift Package Manager(SPM) 與 Linux/Unix 互動。</p><h2>先備知識</h2><ol><li>基礎 Swift 語法知識，若以 Swift.org 的Language guide 目錄為標準，則是 <code>The Basic</code> 至 <code>Methods</code>。</li><li>基礎 Swift <code>Package.init</code> 參數使用，如 <code>name</code>, <code>dependencies</code>, <code>targets</code>。</li><li>基礎 Linux 語法知識，如 <code>ls -alR</code>, <code>Date</code>, <code>whoami</code>。</li></ol><h2>建立可執行的SPM - Hello world</h2><p>我們可以使用 Swift package manager 來建立一個新的 Package project。 如果你對 terminal 熟悉的話，可以閱讀更詳細的文件： <a href="https://github.com/apple/swift-package-manager/blob/master/Documentation/Usage.md">Swift-package-manager/Usage.md</a>。</p><pre><code>$ swift package <span class="keyword">init</span> --type executable --name helloworld
</code></pre><p>這段指令執行了一下事情： 在當前目錄建立一個名為 <code>helloworld</code> 的 可執行的Swift package。</p><p>你可以看到當前目錄建立了一些檔案，下面是使用 <a href="https://formulae.brew.sh/formula/tree"><code>tree</code></a> 的檔案夾結構：</p><pre><code>.
├── <span class="type">Package</span>.<span class="property">swift</span>
├── <span class="type">README</span>.<span class="property">md</span>
├── <span class="type">Sources</span>/
│   └── helloworld/
│       └── main.<span class="property">swift</span>
└── <span class="type">Tests</span>/
    ├── <span class="type">LinuxMain</span>.<span class="property">swift</span>
    └── helloworldTests/
        ├── <span class="type">XCTestManifests</span>.<span class="property">swift</span>
        └── helloworldTests.<span class="property">swift</span>
</code></pre><p>這時我們可以透過以下指令直接執行這個程式</p><pre><code>$ swift build
$ swift run
<span class="type">Hello</span>, world!
</code></pre><p>如此一來就完成基礎的 Command line tool 了！</p><h2><code>Package.swift</code> 取代了 <code>.xcodeproj</code></h2><p>若是你有 Xcode 11, 可以直接打開 <code>Package.swift</code> 就會自動 link 所有檔案並建立 <code>.swiftpm</code></p><pre><code>$ <span class="keyword">open</span> <span class="type">Package</span>.<span class="property">swift</span>
</code></pre><p>可以看到 Package.swift 成為在 XCode 的第一個檔案，以往熟悉的 <code>.xcodeproj</code>不見了。</p><img src="https://i.imgur.com/0e7f6XY.png"/><h2>在執行檔使用第三方函式庫</h2><p>在這裏我們為 helloworld 增加讀取 arguments 的功能，我們可以使用其他已經完善的第三方函式庫，這次我們使用 <code>SPMUtility</code>， 這是來自 Apple 的開源專案，SPM 可以透過 Git 目錄的讀取，執行套件管理並安裝到專案中。我們在 <code>Package.swift</code> 中套用以下的修改：</p><pre><code><span class="comment">// swift-tools-version:5.1</span>

<span class="keyword">import</span> PackageDescription

<span class="keyword">let</span> package = <span class="type">Package</span>(
	name: <span class="string">"helloworld"</span>,
	dependencies: [
		.<span class="call">package</span>(url: <span class="string">"https://github.com/apple/swift-package-manager.git"</span>, from: <span class="string">"0.1.0"</span>)
	],
	targets: [
		.<span class="call">target</span>(
			name: <span class="string">"helloworld"</span>,
			dependencies: [<span class="string">"SPMUtility"</span>]),
		.<span class="call">testTarget</span>(
			name: <span class="string">"helloworldTests"</span>,
			dependencies: [<span class="string">"helloworld"</span>]),
	]
)
</code></pre><blockquote><p>因為函式庫的大小較大，建議網路速度較慢的讀者在這裏先回到 terminal 執行 <code>swift build</code>。</p></blockquote><p>要注意一旦編輯 <code>Package.swift</code> 檔後，必須使用主動儲存變更，XCode 才會更新專案，我們可以使用 File &gt; Save 來主動儲存。 <img src="https://i.imgur.com/S0KXjw8.png"/></p><h2>使用 <code>SPMUtility</code> 讀取 Arguments 與支援其他應用。</h2><p>為了實現讀取 Arguments 的功能，我們要到 <code>main.swift</code> 編寫程式碼！</p><p>首先，通過 import Foundation，我們取得使用者輸入的 Arguments。</p><pre><code><span class="keyword">import</span> Foundation
<span class="keyword">import</span> SPMUtility

<span class="keyword">let</span> arguments = <span class="type">ProcessInfo</span>.<span class="property">processInfo</span>.<span class="property">arguments</span>[<span class="number">1</span>...]

<span class="call">print</span>(<span class="string">"Hello, world!"</span>)
</code></pre><p>使用 ArgumentParser 使 Swift 可以讀取 Arguments。</p><pre><code><span class="keyword">let</span> parser = <span class="type">ArgumentParser</span>(usage: <span class="string">"&lt;options&gt;"</span>, overview: <span class="string">"A Swift command-line tool to say hello"</span>)
<span class="keyword">let</span> nameArgument = parser.<span class="call">add</span>(option: <span class="string">"--name"</span>, shortName: <span class="string">"-n"</span>, kind: <span class="type">String</span>.<span class="keyword">self</span>, usage: <span class="string">"The name to greeting"</span>)
<span class="keyword">let</span> repeatArgument = parser.<span class="call">add</span>(option: <span class="string">"--repeat"</span>, shortName: <span class="string">"-r"</span>, kind: <span class="type">Int</span>.<span class="keyword">self</span>, usage: <span class="string">"The repeat count of Hello"</span>)
</code></pre><p>我們建立了單一 Parser，加入兩個可用的參數，<code>--name</code> 和 <code>--repeat</code>，透過 shortName 的參數建立各自的別名，kind 則建立指定的 Swift 型別。</p><p>接下來我們透過邏輯完成這個應用程式。</p><pre><code><span class="keyword">import</span> SPMUtility
<span class="keyword">import</span> Foundation

<span class="keyword">let</span> arguments = <span class="type">ProcessInfo</span>.<span class="property">processInfo</span>.<span class="property">arguments</span>[<span class="number">1</span>...]

<span class="keyword">let</span> parser = <span class="type">ArgumentParser</span>(usage: <span class="string">"&lt;options&gt;"</span>, overview: <span class="string">"A Swift command-line tool to say hello"</span>)
<span class="keyword">let</span> nameArgument = parser.<span class="call">add</span>(option: <span class="string">"--name"</span>, shortName: <span class="string">"-n"</span>, kind: <span class="type">String</span>.<span class="keyword">self</span>, usage: <span class="string">"The name to greeting"</span>)
<span class="keyword">let</span> repeatArgument = parser.<span class="call">add</span>(option: <span class="string">"--repeat"</span>, shortName: <span class="string">"-r"</span>, kind: <span class="type">Int</span>.<span class="keyword">self</span>, usage: <span class="string">"The repeat count of Hello"</span>)

<span class="keyword">do</span> {
    <span class="keyword">let</span> parsedArguments = <span class="keyword">try</span> parser.<span class="call">parse</span>(<span class="type">Array</span>(arguments))
    <span class="keyword">let</span> name = parsedArguments.<span class="call">get</span>(nameArgument) ?? <span class="string">"world"</span>
    <span class="keyword">var</span> repeatCount = parsedArguments.<span class="call">get</span>(repeatArgument) ?? <span class="number">0</span>
	repeatCount = repeatCount &gt; <span class="number">0</span> ? repeatCount : <span class="number">1</span>
	<span class="keyword">var</span> helloRepeat = [<span class="string">"Hello"</span>]
	<span class="keyword">for _ in</span> <span class="number">1</span>..&lt;repeatCount {
		helloRepeat.<span class="call">append</span>(<span class="string">"hello"</span>)
	}
	<span class="keyword">let</span> holloSentence = helloRepeat.<span class="call">joined</span>(separator: <span class="string">", "</span>)
    <span class="call">print</span>(<span class="string">"</span>\(holloSentence)<span class="string">,</span> \(name)<span class="string">"</span>)
} <span class="keyword">catch</span> {
    <span class="call">print</span>(<span class="string">"helloworld greeting failed:</span> \(error)<span class="string">"</span>)
}

</code></pre><p>現在，我們來測試看看！在 terminal 裡執行以下指令，你應該看到應用程式的結果。</p><pre><code>$ swift run helloworld --name yu --<span class="keyword">repeat</span> <span class="number">3</span>
<span class="type">Hello</span>, hello, hello, yu
</code></pre><p>ArgumentParser 同時也提供 <code>--help</code> 的功能。</p><pre><code>$ swift run swift run helloworld --help
<span class="type">OVERVIEW</span>: <span class="type">A Swift</span> command-line tool to say hello

<span class="type">USAGE</span>: helloworld &lt;options&gt;

<span class="type">OPTIONS</span>:
  --name, -n     <span class="type">The</span> title to greeting
  --<span class="keyword">repeat</span>, -r   <span class="type">The</span> <span class="keyword">repeat</span> count of <span class="type">Hello</span>
  --help         <span class="type">Display</span> available options
</code></pre><h2>將 SPM 打包並安裝到 Unix 上</h2><p>在經歷了各種測試後，我們的 helloworld 已經可以作為一個日常的使用工具，透過以下的方式，將執行檔安裝到 terminal 上。</p><pre><code>$ swift build --configuration release
$ cp -f .<span class="dotAccess">build</span>/release/helloworld /usr/local/bin/helloworld
</code></pre><p>如此一來，就可以使用了！</p><pre><code>$ helloworld --help
<span class="type">OVERVIEW</span>: <span class="type">A Swift</span> command-line tool to say hello

<span class="type">USAGE</span>: helloworld &lt;options&gt;

<span class="type">OPTIONS</span>:
  --name, -n     <span class="type">The</span> title to greeting
  --<span class="keyword">repeat</span>, -r   <span class="type">The</span> <span class="keyword">repeat</span> count of <span class="type">Hello</span>
  --help         <span class="type">Display</span> available options
</code></pre><p>以上，就是如何製作一個CLI！</p>]]></content:encoded></item><item><guid isPermaLink="true">https://ytyubox.github.io/posts/2020/02/12/CryptoKit</guid><title>iOS 13 針對加密的framework：CryptoKit</title><description>介紹 CryptoKit 與 MD5 的使用</description><link>https://ytyubox.github.io/posts/2020/02/12/CryptoKit</link><pubDate>Wed, 12 Feb 2020 00:00:00 +0000</pubDate><content:encoded><![CDATA[<h1>iOS 13 針對加密的framework：CryptoKit</h1><p>以往要使用加密的函式時，需要接觸 C api，依照 StackOverflow 上的解答，可以使用 <code>CC_MD5</code></p><blockquote><p>在 C 語言 需 <code>#include &lt;openssl/md4.h&gt;</code></p></blockquote><p>StackOverflow link :https://stackoverflow.com/a/32166735/10172299</p><h2>iOS 的 CryptoKit</h2><pre><code><span class="keyword">import</span> CryptoKit

<span class="keyword">var</span> md5 = <span class="type">Insecure</span>.<span class="type">MD5</span>()

md5.<span class="call">update</span>(data: <span class="string">"1234567890"</span>.<span class="call">data</span>(using: .<span class="dotAccess">utf8</span>)!)

<span class="keyword">let</span> digest: <span class="type">Insecure</span>.<span class="type">MD5</span>.<span class="type">Digest</span> = md5.<span class="call">finalize</span>()

<span class="call">print</span>(digest)
<span class="comment">// MD5 digest: e807f1fcf82d132f9bb018ca6738a19f</span>
</code></pre><h2>詳細的 WWDC</h2><p>WWDC 2019 - session 709 - Cryptography and Your Apps: https://developer.apple.com/videos/play/wwdc2019/709/</p>]]></content:encoded></item><item><guid isPermaLink="true">https://ytyubox.github.io/posts/2020/01/28/super-useful-mac-tip</guid><title>超級超好用的蘋果電腦密技</title><description>介紹一些要用的 macOS 使用方式</description><link>https://ytyubox.github.io/posts/2020/01/28/super-useful-mac-tip</link><pubDate>Tue, 28 Jan 2020 00:00:00 +0000</pubDate><content:encoded><![CDATA[<h1>超級超好用的蘋果電腦密技 (一) 文字編輯篇</h1><p>我認識很多朋友因為覺得 macOS 在使用上比 Windows 方便而買了一台 MacBook, 但是由於對作業系統的整體邏輯不熟, 常常會有許多問題請教. 例如輸入法切換, 好用的工具程式等等. 這次介紹我的 macOS 日常使用的技巧與一些配置. 這次是在 macOS 10.15.2 的環境下所下的指令. 文章有提供一些練習的方式, 如果覺得不錯可以留言給我一些回饋.</p><h2>文字編輯方式</h2><h3>1. Windows 的向後刪除</h3><p>在中文與英文一般的方式下, <code>delete</code> 的文字刪除方向是向左刪除, 也就是文字段落的前方. 在 Windows 上, 可以使用 <code>DEL</code> 來向左刪除, 而 macOS 的可以使用 <code>fn</code> + <code>delete</code> 來達到同樣效果.</p><label>在這練習</label><textarea>"點我進入編輯模式: 使用 fn + delete 來反向刪除"</textarea><h3>2. 快速移動文字指標</h3><p>很多時候會有移動文字指標並繼續打字的情況發生, 在 macOS 可以使用 <code>option</code> + <code>左右箭頭</code>, 來依照文字快速移動, 在單行的文字修改可以快速跳躍文字段落. 如果想快速移動到單行的最前/最後, 可以使用 <code>command</code> + <code>左右箭頭</code> 來移動, 我在打這個段落的時候就使用很多次這個技巧, 非常實用.</p><div class "practice">
<label>在這練習</label>
<textarea>點我進入編輯模式: 使用 option + 左右箭頭, 快速移動 CURSOR 到上一個/下一個單字(單字範圍由 macOS 決定的)</textarea>
<textarea>點我進入編輯模式: 使用 command + 左右箭頭, 快速移動 cursor 到一行的最前與最後</textarea>
</div><h3>3. 段落選取方式</h3><p>可以用鍵盤和觸碰版快速完成文字選取的任務.</p><p>鍵盤使用類似上面移動文字指標的方式, 不過這個要加上 <code>shift</code>, 可以在段落中間使用 <code>command</code> + <code>shift</code> + <code>左右箭頭</code>, 選取一半的文字.</p><div class "practice">
    <label>在這練習</label>
    <textarea>"點我進入編輯模式:  使用 shift + command/optional + 箭頭來快速選取文字, shift 通常都是複選的指令"</textarea>
</div><p>觸屏版可以使用 3 指移動的方式選取, 這功能需要一系列的設定: 如果你的 Mac 配備「 <a href="https://en.wikipedia.org/wiki/Force_Touch">力度觸控軌跡板</a> 」，開啟三指拖曳功能的步驟如下。</p><ol>
    <li>
        打開「系統偏好設定」的「輔助使用」。
        <img src="https://i.imgur.com/ZiMWnbV.png">
    </li>
    <li> 從左側選項中選擇「滑鼠與觸控式軌跡板」。</li>
    <li> 按一下「觸控式軌跡板選項」。</li>
    <li> 勾選「啟用拖移」旁的勾選框。 </li>
    <li> 從相關的彈出式選單中，選擇「三指拖曳」功能，旁邊就會出現剔號。</li>
    <li> 按一下「確定」。</li>
</ol><img src="https://i.imgur.com/rqhGf5r.png">



<div></div>

<h3>4. 像 iPhone 一樣用說話來打字 (聽寫) </h3>

<img src="https://help.apple.com/assets/5DB8A4A0094622D56C6D1279/5DB8A4AE094622D56C6D1281/zh_TW/30671b9e91fdd1b0040201b023745266.png">

圖片來自 <a href="https://support.apple.com/zh-tw/guide/mac-help/mh40584/mac">https://support.apple.com/zh-tw/guide/mac-help/mh40584/mac</a> 

<div></div>

可以在任何可輸入的位置聽寫文字. macOS 會將您的字詞傳送至 Apple 伺服器進行分析並轉換為文字, 也因此只能在有網路的使用使用. 開啟聽寫的步驟如下: 

<ol>
<li>開啟「系統偏好設定」的「鍵盤」.</li>
<img src="https://i.imgur.com/xDGGUaB.png">
    <li>點擊「聽寫」.</li>
    <li>按一下「開啟」。若有提示出現，按一下「啟用聽寫」。</li>
    <li>選擇聽寫啟用使用所使用的語言.</li>
    <li>選擇啟用聽寫的快速鍵. </li>
</ol>




<img src="https://i.imgur.com/DrZlGFt.png" width="780px">

<div class "practice">
    <label>在這練習</label>
    <textarea>"點我進入編輯模式:  使用 fu + fu 來啟動聽寫, 請注意不要影響旁人"</textarea>
</div>









以上是一些我常用或是有趣的 macOS 文字秘技, 歡迎留言告訴我你的想法.

參考資訊:
<ol>
    
 <li>apple - 為 Force Touch 觸控式軌跡板開啟「三指拖移」 - Apple 支援: https://support.apple.com/zh-tw/HT204609</li>
 <li>wiki - Force Touch - Wikipedia: https://en.wikipedia.org/wiki/Force_Touch</li>
<li>apple - 在 Mac 上聽寫訊息和文件 - Apple 支援:  https://support.apple.com/zh-tw/guide/mac-help/mh40584/mac</li>

</ol>
]]></content:encoded></item><item><guid isPermaLink="true">https://ytyubox.github.io/posts/2020/Publish-apply-GA-SEO</guid><title>Swift Publish 套用 Google Analytics 與 SEO</title><description>為 Publish 套用 Google 分析與搜尋引擎優化</description><link>https://ytyubox.github.io/posts/2020/Publish-apply-GA-SEO</link><pubDate>Thu, 9 Jan 2020 00:00:00 +0000</pubDate><content:encoded><![CDATA[<h1>Swift Publish 套用 Google Analytics 與 SEO</h1>]]></content:encoded></item><item><guid isPermaLink="true">https://ytyubox.github.io/posts/2020/Asyc-GitHub-exp</guid><title>使用 Async 輕量非同步套件鏈式調用非同步行為</title><description>Async explain and try to extend it</description><link>https://ytyubox.github.io/posts/2020/Asyc-GitHub-exp</link><pubDate>Mon, 6 Jan 2020 00:00:00 +0000</pubDate><content:encoded><![CDATA[<h1>使用 Async 輕量非同步套件鏈式調用非同步行為</h1><p>Async: <a href="https://github.com/duemunk/Async">github.com/duemunk/Async</a></p><p>2019 年介紹 <code>Combine</code> 時 <a href="https://ithelp.ithome.com.tw/users/20119945/ironman/2272">2019鐵人賽介紹 Combine 系列</a>, 對於連續的非同步事件的調用, 我們會遇到回呼地獄(Callback hell), 也就是多筆具相依的非同步步驟響應辦法.<br><br>## <code>Async</code> 的解法 相較於原本的 DispatchQueue 的版本:</p><pre><code><span class="type">DispatchQueue</span>.<span class="call">global</span>(qos: .<span class="dotAccess">userInitiated</span>).<span class="call">async</span> {
    <span class="keyword">let</span> value = <span class="number">10</span>
    <span class="type">DispatchQueue</span>.<span class="call">global</span>(qos: .<span class="dotAccess">background</span>).<span class="call">async</span> {
        <span class="keyword">let</span> text = <span class="string">"Score:</span> \(value)<span class="string">"</span>
        <span class="type">DispatchQueue</span>.<span class="property">main</span>.<span class="call">async</span> {
            label.<span class="property">text</span> = text
        }
    }
}
</code></pre><pre><code><span class="type">Async</span>
.<span class="call">userInitiated</span> { <span class="number">10</span> }
.<span class="call">background</span> { <span class="string">"Score:</span> \($0)<span class="string">"</span>}
.<span class="call">main</span> { label.<span class="property">text</span> = $0 }
</code></pre><p><code>Async</code>很像瀑布一樣, 由上至下的思考非同步的執行流程.</p><h2><code>Async</code> 沒有對錯誤拋出處理 <code>throws</code></h2><p>在研究了一段時間發現, <code>Async</code> 很可惜的沒有對 <code>Error handle</code> 做處理, 決定研究了一下, 修改部分的程式碼, <a href="https://github.com/ytyubox/Async">fork repo</a>.</p><pre><code><span class="keyword">private class</span> Reference&lt;T&gt; {
        <span class="keyword">var</span> value: <span class="type">T</span>?
<span class="comment">/*新增*/</span>    <span class="keyword">var</span> error:<span class="type">Error</span>? 
<span class="comment">/*新增*/</span>    <span class="keyword">var</span> queue:<span class="type">GCD</span>?   
}
</code></pre><pre><code><span class="keyword">public struct</span> AsyncBlock&lt;In, Out&gt; {

    ...


    <span class="keyword">private static func</span> async&lt;O&gt;(after seconds: <span class="type">Double</span>? = <span class="keyword">nil</span>,
                                 block: <span class="keyword">@escaping</span> () <span class="keyword">throws</span> -&gt; <span class="type">O</span>,
                                 queue: <span class="type">GCD</span>) -&gt; <span class="type">AsyncBlock</span>&lt;<span class="type">Void</span>, <span class="type">O</span>&gt; {
        <span class="keyword">let</span> reference = <span class="type">Reference</span>&lt;<span class="type">O</span>&gt;()
<span class="comment">/*新增*/</span>    reference.<span class="property">queue</span> = queue
        <span class="keyword">let</span> block = <span class="type">DispatchWorkItem</span>(block: {
<span class="comment">/*新增*/</span>        <span class="keyword">do</span> {
<span class="comment">/*新增*/</span>            reference.<span class="property">value</span> = <span class="keyword">try</span> <span class="call">block</span>()
<span class="comment">/*新增*/</span>        }<span class="keyword">catch</span> {
<span class="comment">/*新增*/</span>            reference.<span class="property">error</span> = error
<span class="comment">/*新增*/</span>        }
        })
      ...
    }
 
    <span class="keyword">private func</span> chain&lt;O&gt;(after seconds: <span class="type">Double</span>? = <span class="keyword">nil</span>,
                          block chainingBlock: <span class="keyword">@escaping</span> (<span class="type">Out</span>) <span class="keyword">throws</span> -&gt; <span class="type">O</span>,
                          queue: <span class="type">GCD</span>) -&gt; <span class="type">AsyncBlock</span>&lt;<span class="type">Out</span>, <span class="type">O</span>&gt; {
        <span class="keyword">let</span> reference = <span class="type">Reference</span>&lt;<span class="type">O</span>&gt;()
<span class="comment">/*新增*/</span>            reference.<span class="property">queue</span> = queue
        <span class="keyword">let</span> dispatchWorkItem = <span class="type">DispatchWorkItem</span>(block: {
<span class="comment">/*新增*/</span>        <span class="keyword">guard let</span> value = <span class="keyword">self</span>.<span class="property">output_</span>.<span class="property">value</span> <span class="keyword">else</span> {
<span class="comment">/*新增*/</span>            <span class="keyword">return</span> reference.<span class="property">error</span> = <span class="keyword">self</span>.<span class="property">output_</span>.<span class="property">error</span>!
<span class="comment">/*新增*/</span>        }
<span class="comment">/*新增*/</span>        <span class="keyword">do</span> {
<span class="comment">/*新增*/</span>            reference.<span class="property">value</span> = <span class="keyword">try</span> <span class="call">chainingBlock</span>(value)
<span class="comment">/*新增*/</span>        } <span class="keyword">catch</span> {
<span class="comment">/*新增*/</span>            reference.<span class="property">error</span> = error
<span class="comment">/*新增*/</span>        }
        })

    ...
    }

...

}
</code></pre><p>如此一來, 就可以對 <code>AsyncBlock</code> 拓展 <code>catch(_:)</code></p><pre><code><span class="comment">/*新增*/</span>
<span class="keyword">@discardableResult
public func</span> `catch`(respondBlock: <span class="keyword">@escaping</span> (<span class="type">Error</span>) -&gt; <span class="type">Void</span>) -&gt; <span class="type">AsyncBlock</span>&lt;<span class="type">In</span>,<span class="type">Out</span>&gt; {
    <span class="keyword">let</span> queue = output_.<span class="property">queue</span>!.queue
    <span class="keyword">let</span> c = {
        <span class="keyword">if let</span> error = <span class="keyword">self</span>.<span class="property">output_</span>.<span class="property">error</span> {
            <span class="call">respondBlock</span>(error)
        }
    }
    <span class="keyword">let</span> item = <span class="type">DispatchWorkItem</span>(block: c)
    block.<span class="call">notify</span>(queue: queue, execute: item)
    <span class="keyword">return self</span>
}
</code></pre><p>實作單元測試:</p><pre><code><span class="keyword">func</span> testAsyncMainWithCatch() {
    <span class="keyword">let</span> expectation = <span class="keyword">self</span>.<span class="call">expectation</span>(description: <span class="string">"Expected on main queue"</span>)
    <span class="keyword">var</span> calledStuffAfterSinceAsync = <span class="keyword">false</span>
    <span class="type">Async</span>.<span class="call">main</span> {
        <span class="keyword">try self</span>.<span class="call">alwaysError</span>()
    }.<span class="keyword">catch</span> { (error) <span class="keyword">in</span>
        <span class="preprocessing">#if targetEnvironment(simulator)</span>
        <span class="call">XCTAssert</span>(<span class="type">Thread</span>.<span class="property">isMainThread</span>, <span class="string">"Should be on main thread (simulator)"</span>)
        <span class="preprocessing">#else</span>
        <span class="call">XCTAssertEqual</span>(<span class="call">qos_class_self</span>(), <span class="call">qos_class_main</span>())
        <span class="preprocessing">#endif</span>
        <span class="call">XCTAssert</span>(calledStuffAfterSinceAsync, <span class="string">"Should be async"</span>)
        expectation.<span class="call">fulfill</span>()
    }
    calledStuffAfterSinceAsync = <span class="keyword">true</span>
    waitForExpectations(timeout: timeMargin, handler: <span class="keyword">nil</span>)
}
</code></pre><p>以上, 於 fork 的 GitHub project 內持續補上 test case! GitHub 連結: https://github.com/ytyubox/Async</p>]]></content:encoded></item><item><guid isPermaLink="true">https://ytyubox.github.io/posts/2020/iOS-Vibration</guid><title>iOS 實機測試震動</title><description>iOS Vibration note</description><link>https://ytyubox.github.io/posts/2020/iOS-Vibration</link><pubDate>Sun, 5 Jan 2020 00:00:00 +0000</pubDate><content:encoded><![CDATA[<h1>iOS 實機測試震動</h1><img src="https://github.com/ytyubox/tryViber-iOS/blob/master/demo-tryViber.jpeg?raw=true"/><p>每次時間不可改，最小間隔 0.5 秒</p><pre><code><span class="keyword">import</span> AudioToolbox

<span class="type">AudioServicesPlayAlertSound</span>(<span class="type">SystemSoundID</span>(kSystemSoundID_Vibrate))
</code></pre><h2>套用 Swift 5.1 的 <code>Property Wrapper</code></h2><pre><code><span class="keyword">import</span> AudioToolbox

<span class="keyword">@propertyWrapper
struct</span> SoundId {
    <span class="keyword">typealias</span> Value = <span class="type">UInt32</span>
    <span class="keyword">var</span> projectedValue: <span class="type">SystemSoundID</span>
    <span class="keyword">var</span> wrappedValue: <span class="type">Value</span> {
        <span class="keyword">didSet</span> {
            projectedValue = .<span class="keyword">init</span>(<span class="keyword">self</span>.<span class="property">wrappedValue</span>)
        }
    }
    
    <span class="keyword">init</span>(wrappedValue: <span class="type">Value</span>) {
        <span class="keyword">self</span>.<span class="property">projectedValue</span> = <span class="type">SystemSoundID</span>(wrappedValue)
        <span class="keyword">self</span>.<span class="property">wrappedValue</span> = wrappedValue
    }
}

<span class="keyword">class</span> SOMECLASS {
    <span class="keyword">@SoundId var</span> currentSystemEffect = kSystemSoundID_Vibrate
    
    <span class="keyword">func</span> playSound() {
        <span class="type">AudioServicesPlaySystemSound</span>(<span class="keyword">self</span>.$currentSystemEffect)
    }
}
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://ytyubox.github.io/posts/2020/01/04/Git-team-init</guid><title>新團隊建立 Git 指南 (一)</title><description>Git 團隊手冊中針對新團隊的章節</description><link>https://ytyubox.github.io/posts/2020/01/04/Git-team-init</link><pubDate>Sat, 4 Jan 2020 00:00:00 +0000</pubDate><content:encoded><![CDATA[<h1>新團隊建立 Git 指南 (一)</h1><img src="https://i.imgur.com/LLQU4xt.jpg"/><p>在 Git 團隊使用手冊中, 介紹了如何在多人團隊中建立 Git 的方式.</p><h2>1. 耐心與同情心</h2><p>有同情心的團隊會為新手留下說明操作程序的文件, 回答新人問題. "Help me, help you.", 就是專案領導人該有的口號!</p><p>目標: 一致性的部分都留下詳細的指引, 樣板及自動化腳本, 將標準之外的情況視為自己應該解決的程序問題.</p><img src="https://i.imgur.com/qvkTcc9.png"/><p>推薦影片教學 https://player.oreilly.com/videos/9781491912003</p><h2>2. 建立 Repository</h2><p>不論選擇 GitHub/GitLab, 第一需要考慮的問題是: 該用哪個賬號建立 Repo? 首先, 在 repo 的 URL 通常會以 <code>https://&lt;代管系統主機&gt;.com/&lt;REPO擁有者&gt;/</code>, 端看這個專案(repo) 是屬於自己或是或是所屬的機構(公司), 選擇專案的擁有者.</p><p>第二, 決定專案各種權限: 對於開源專案, <code>READ</code> 的權限是開發的, 但對於 <code>WRITE</code> 的權限分成組織開發者, 非組織貢獻者. 對於這些分別的最大差別, 最主要的分別是: 可以同意寫入的能力, 例如一位非組織貢獻者想貢獻一部份的 code modification, 若使用的是 <code>GitHub</code> 服務, 則必須 <code>fork</code> 一份在自己賬號的複製專案, 推送改動, 並發起 <code>Pull Request</code>, 由組織開發者同意是否同意寫入.</p><h2>3. 沒有寫入權限的專案成員對專案的貢獻步驟</h2><ol><li>not folk</li></ol><pre><code>git colne <span class="type">REPOURL REPO</span>
cd <span class="type">REPO</span>
git remote add personal <span class="type">MYREPOURL</span>
git branch my-proposal
git checkout my-proposal

# <span class="keyword">do</span> all the concreate change

git add <span class="type">FILE</span>
git commit -m 'finish change start porposal'
git push personal my-proposal
</code></pre><p>發起 Pull Request</p><ol start="2"><li>folk</li></ol><p>在專案託管系統 folk 一份在自己賬號之下</p><pre><code>git clone <span class="type">MYFORKURL REPO</span>
cd <span class="type">REPO</span>
git remote add <span class="type">REPOURL</span> offical
git branch my-proposal
git checkout my-proposal

# <span class="keyword">do</span> all the concreate change

git add <span class="type">FILE</span>
git commit -m 'finish change start porposal'
git push original my-proposal
</code></pre><p>一樣發起 Pull Request</p><p>下一篇將介紹維護者要如何處理 Pull Request</p>]]></content:encoded></item><item><guid isPermaLink="true">https://ytyubox.github.io/posts/2020/bulid-static-web-by-publish</guid><title>[#1] 如何透過 Publish 使用 100 % Swift code 建立 Blog</title><description>使用 Markdown 編寫文章, 利用 Publish 框架, 架設靜態網站</description><link>https://ytyubox.github.io/posts/2020/bulid-static-web-by-publish</link><pubDate>Wed, 1 Jan 2020 00:00:00 +0000</pubDate><content:encoded><![CDATA[<h1>[#1] 如何透過 Publish 使用 100 % Swift code 建立 Blog</h1><p>起源: 2019 年, 接觸了剛起步的 <a href="https://www.swiftbysundell.com/">Swift by Sundell</a>, Sundell 是一個全職的作者, 不僅每週有固定的文章與 Podcast, 還不時的在各大 Swift 有關的演講分享, 而在 2019 年 12 月底, Sundell 推出了 <a href="https://github.com/JohnSundell/Publish">Publish</a></p><iframe width="560" height="315" src="https://www.youtube.com/embed/pAy6v4MEsnc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><p>Jhon Sundell @SwiftServerConf, 2019/11</p><blockquote><p><code>Publish</code> 於 2020 年 1 月 版號是 <code>v0.1.0</code>, 代表 還有不少的功能還沒實現, Sundell 對於新功能是採用 <code>PR please</code> 的方式, 也就是不接受 issue, 只接受貢獻, 因此某種程度是更新較慢的.</p></blockquote><h2>Publish 框架環境與安裝</h2><ol><li>Swift 5.1</li><li>Swift Package manager: swift-tools-version:5.1</li><li>PublishCLI: Publish <code>v0.1.0</code></li></ol><p>Step 1: 安裝 <code>Publish</code></p><pre><code class="language-no-highlight">git clone https://github.com/JohnSundell/Publish.git
cd Publish
make
</code></pre><p>透過 <code>MakeFile</code>, 將安裝 <code>publish-cli</code> 至 <code>/usr/local/bin/</code>, 就可以使用 <code>publish</code></p><p>Step 2: 靜態網頁建立</p><pre><code class="language-no-highlight">mkdir __WEBSITE_NAME__ 
cd __WEBSITE_NAME__
publish new
</code></pre><p>透過 <code>PublishCLI</code> 建立 <code>Package.swift</code>, 之後可以用 XCode 編輯</p><h2>Publish 整體架構</h2><pre><code class="language-no-highlight">├── Content/
│   ├── index.md
│   └── posts/
│       ├── first-post.md
│       └── index.md
├── Package.swift
├── Resources/
└── Sources/
    └── __WEBSITE_NAME__/
        └── main.swift

</code></pre><p>Publish 框架下使用 <code>SPM</code> 來處理整個由 <code>Read *.md</code> ~&gt; <code>gen *.html, Theme.css</code> ~&gt; <code>Site metadata</code> 的過程, 程式相依資源是由 <code>Package.swift</code>控制, 分頁的讀取由 <code>main.swift</code>觸發, 文章的來源是相依從 <code>Content/</code> 取得, 主要設計由 main.swift 的 <code>try SomeWebsite().publish(...)</code>, 其中包含基本網站的 metaData, building 的介入 等.</p><pre><code><span class="keyword">import</span> Foundation
<span class="keyword">import</span> Publish
<span class="keyword">import</span> Plot

<span class="comment">// This type acts as the configuration for your website.</span>
<span class="keyword">struct</span> Publishdemo: <span class="type">Website</span> {
    <span class="keyword">enum</span> SectionID: <span class="type">String</span>, <span class="type">WebsiteSectionID</span> {
        <span class="keyword">case</span> posts
    }

    <span class="keyword">struct</span> ItemMetadata: <span class="type">WebsiteItemMetadata</span> {
        <span class="comment">// Add any site-specific metadata that you want to use here.</span>
    }

    <span class="comment">// Update these properties to configure your website:</span>
    <span class="keyword">var</span> url = <span class="type">URL</span>(string: <span class="string">"https://your-website-url.com"</span>)!
    <span class="keyword">var</span> name = <span class="string">"Publishdemo"</span>
    <span class="keyword">var</span> description = <span class="string">"A description of Publishdemo"</span>
    <span class="keyword">var</span> language: <span class="type">Language</span> { .<span class="dotAccess">english</span> }
    <span class="keyword">var</span> imagePath: <span class="type">Path</span>? { <span class="keyword">nil</span> }
}

<span class="keyword">try</span> <span class="type">Publishdemo</span>().<span class="call">publish</span>(withTheme: .<span class="dotAccess">foundation</span>)
</code></pre><h2>使用 GitHub page 作為 發佈空間</h2><p>GitHub 在每個賬號下可以有固定一個免費的靜態網站的空間, 原意是可以作為 open source 的 doc 或是基本的 intro, 而作為個人使用賬號, 可以用來作為個人的 blog. 1. 與GitHub 建立一個 repo, 名稱必須是<code>該賬號.github.io</code> , 這樣才可以被 GitHub 識別. 2. (很重要) 不要對哪個 repo 作任何 push. 3. 與你的 <code>main.swift</code> 內建的<code>.publish(withTheme:)</code>修改為一下</p><pre><code><span class="keyword">try</span> <span class="type">MyWebSite</span>().<span class="call">publish</span>(
    withTheme: .<span class="dotAccess">foundation</span>,
    deployedUsing: .<span class="call">git</span>(<span class="string">"https://github.com/ytyubox/ytyubox.github.io"</span>)
)
</code></pre><ol start="4"><li>使用 terminal 指令 <code>publish deploy</code> 直接上傳到 GitHub.</li></ol>]]></content:encoded></item></channel></rss>